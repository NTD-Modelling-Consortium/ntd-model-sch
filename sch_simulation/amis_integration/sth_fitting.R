source("amis_integration.R")

args <- commandArgs(trailingOnly = TRUE)
num_cores_to_use <- parallel::detectCores()
if (length(args) == 1) {
  num_cores_to_use <- as.integer(args)
}

print(paste0("Using ", num_cores_to_use, " cores"))

sch_simulation <- get_amis_integration_package()

fixed_parameters <- sch_simulation$FixedParameters(
  # the higher the value of N, the more consistent the results will be
  # though the longer the simulation will take
  number_hosts = 10L,
  # no intervention
  coverage_file_name = "mansoni_coverage_scenario_0.xlsx",
  demography_name = "UgandaRural",
  # cset the survey type to Kato Katz with duplicate slide
  survey_type = "KK2",
  parameter_file_name = "mansoni_params.txt",
  coverage_text_file_storage_name = "Man_MDA_vacc.txt",
  # the following number dictates the number of events (e.g. worm deaths)
  # we allow to happen before updating other parts of the model
  # the higher this number the faster the simulation
  # (though there is a check so that there can't be too many events at once)
  # the higher the number the greater the potential for
  # errors in the model accruing.
  # 5 is a reasonable level of compromise for speed and errors, but using
  # a lower value such as 3 is also quite good
  min_multiplier = 5L
)

# Example prevalence map (generated by the "map_samples_example.R")
# Example prevalence map, with nine locations, fitting to three time points
map <- read.csv("./data/map.csv")

L <- 9
years <- c(2000, 2010, 2020)
num_years <- length(years)
location_names <- paste0("IU_", 1:L)

prevalence_map <- vector("list", num_years)
for (j in 1:num_years) {
  prev_year_j <- dplyr::filter(map, year == years[j])
  mat <- as.matrix(prev_year_j[, -c(1, 2)])
  rownames(mat) <- prev_year_j$IU_code
  prevalence_map[[j]]$data <- mat
}

#' the "dprior" function
#' Note the second parameter _must_ be called log
#' This function calculates the prior density (in log-scale or not) for each parameter value
dprior <- function(x, log = FALSE) {
  if (log) {
    return(dunif(x[1], 1.91772, 12.0, log = TRUE) + dunif(x[2], 0.001, 0.5, log = TRUE))
  } else {
    return(dunif(x[1], 1.91772, 12.0) * dunif(x[2], 0.001, 0.5))
  }
}
#' The "rprior" function that returns a matrix whose columns are the parameters
#' and each row is a sample
rprior <- function(n) {
  ret <- cbind(runif(n, 1.91772, 12.0), runif(n, 0.001, 0.5))
  colnames(ret) <- c("R0", "k")
  return(ret)
}
prior <- list(rprior = rprior, dprior = dprior)

# year_indices <- c(2000L, 2010L, 2020L)
year_indices <- c(1L, 2L, 3L)


amis_params <- AMISforInfectiousDiseases:::default_amis_params()
amis_params$sigma <- 0.01
amis_output <- AMISforInfectiousDiseases::amis(
  prevalence_map = prevalence_map,
  transmission_model = build_transmission_model(prevalence_map, fixed_parameters, year_indices, num_cores_to_use),
  prior = prior,
  amis_params = amis_params
)

print(amis_output)
